import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class Db {
    private final static String URL = "jdbc:postgresql://localhost/Java_1";
    private final static String USER_DB = "postgres";
    private final static String PASSWORD = "7777";

    /**
     * Метод, який створюватиме таблицю БД
     */
    public static void createUsersTable() {
        // для кожного запиту до БД потрібно створити з'єднання
        // Кожен раз, коли здійснюється маніпуляція з БД відкривається деякий поток

        /** Створення об'єкта Connection - встановлює зв'язок з БД - ініціалізується у try-catch блоку */
        Connection connection = null;

        /** Створення об'єкта Statement - дає змогу створювати SQL запити до БД, створюється через об'єкт Connection - ініціалізується у try-catch блоку */
        Statement statement = null;

        try {
            /**
             * Використання об'єкта інтерфейсу Connection
             * - потребує обернення у try-catch блок, оскільки генерує виключну ситуацію у разі вказання некоректних даних у параметрах
             *
             * Створюється за допомогою фабричного методу DriverManager, який має статичний метод getConnection(), що приймає наступні параметри
             * - інформацію про те куди потрібно підключитись - по якій URL-адресі - jdbc:postgresql://localhost/Java_1
             * - хто підключається - postgres
             * - пароль доступу - 7777
             */
            connection = DriverManager.getConnection(URL, USER_DB, PASSWORD);

            /** Для виконання запитів до БД використовується об'єкт Statement - інтерфейс з бібліотеки java.sql
             * отримується за допомогою об'єкта connection */
            statement = connection.createStatement();

            /** Створення запитів відбувається через виклик методу statement.execute()
             * у параметри якого у вигляді рідка передається сам SQL запит
             * Розшифровка запиту:
             * - CREATE TABLE users() - команда на створення таблиці, мінімальний синтаксис, у дужках можуть бути вказані колонки таблиці
             * - IF NOT EXISTS - уточнювальна умова на створення таблиці у разі її відсутності (повторний запуск методу/програми не призведе до помилки)
             * - BIGSERIAL - тип даних поля, що містить первинний ключ - у PostgreSQL спеціальний цілочисельний тип даних, який заміняє автоінкремент
             * - PRIMARY KEY - атрибут поля, яке містить первинний ключ
             * - NOT NULL - властивість, яка забороняє збергати у полі значення NULL - поле не поме бути пустим
             * - VARCHAR(25) - тип даних для текстового поля, яке міститиме до 25 символів */
            statement.execute("CREATE TABLE IF NOT EXISTS users(id BIGSERIAL PRIMARY KEY NOT NULL, firstName VARCHAR(25) NOT NULL, lastName VARCHAR(25) NOT NULL)");

        } catch (SQLException e) {
            e.printStackTrace();
        } finally { // блок finally для розміщення коду, що здійснюватиме закриття потоку - при необхідності позбутись даного блоку та спростити код застосовують - try з ресурсами
            /** Закриття потоків здійснюється у порядку, зворотньому їх створенню */

            /** Закриття потоку statement
             * - оскільки об'єкт Statement може бути не проініціалізований в результаті генерування виключення
             *   (NullPointerException при спробі викликати метод close() у змінної, що не було проініціалізовано, тобто = null),
             *   його варто захистити перевіркою на рівність null,
             * - метод close() може генерувати виключну ситуацію, тому його обгортають у окремий try-catch блок */
            if (statement != null) {
                try { // метод close() може генерувати виключну ситуацію, тому його обгортають у окремий try-catch блок
                    statement.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            /** Закриття потоку connection
             * - оскільки об'єкт Connection може бути не проініціалізований в результаті генерування виключення
             *   (NullPointerException при спробі викликати метод close() у змінної, що не було проініціалізовано, тобто = null),
             *   його варто захистити перевіркою на рівність null,
             * - метод close() може генерувати виключну ситуацію, тому його обгортають у окремий try-catch блок */
            if (connection != null) {
                try { // метод close() може генерувати виключну ситуацію, тому його обгортають у окремий try-catch блок
                    connection.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * Метод для вставки інформації
     */
    public static void insertUser(User user) {
        /** У даному методі також ВІДКРИВАТИМУТЬСЯ потоки Connection та Statement,
         * які по завершенню запису інформації до БД потрібно буде ЗАКРИТИ, тому
         * для зменшення кількості коду, його оптимізації, рекомендується
         * скористатись блоком try з ресурсами (дозволить позбавитись громіздкого блоку finally)
         *
         * Розміщення ресурсів у дужках блоку try вказує, що вони будуть відкриті та
         * по завершенні роботи коду у тілі блоку потребують закриття у автоматичному режимі */
        try (Connection connection = DriverManager.getConnection(URL, USER_DB, PASSWORD);
             Statement statement = connection.createStatement();) {

            // тіло блоку try-catch - тут знаходитиметься код, що потрібно безпечно виконати

            /** Запит на додавання/вставку даних до таблиці БД - SQL-запит
             * При створенні запиту слід зазначити, що строкові значення мають знаходитись у одинарних лапках '', а також
             * для передачі змінних класу до рядка запиту слід застосувати конкатенацію */
            //statement.execute("INSERT INTO users(firstName, lastName) VALUES('" + user.getFirstName() + "', '" + user.getLastName() + "')");

            /** Інший спосіб реалізації запиту без помилконебезпечного варіанта з конкатенацією - форматований рядок
             * (працює схожим чином на метод System.out.printf(""))
             * повертає форматований рядок - готовий SQL-запит */
            String sql = String.format("INSERT INTO users(firstName, lastName) VALUES('%s', '%s')",
                    user.getFirstName(),
                    user.getLastName());

            // Виведення у консоль форматованого рядка для перевірки коректності роботи методу format()
            System.out.println(sql);

            /** Запит на додавання/вставку даних до таблиці БД */
            statement.execute(sql);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * Метод читання вмісту таблиці
     */
    public static List<User> getAllUsers() {
        /** Підготовлений список повернення - заповнюватиметься об'єктами при читанні БД */
        List<User> users = new ArrayList<>();

        // логіка підключення до БД та наповнення колекції users даними
        /** У даному методі також ВІДКРИВАТИМУТЬСЯ потоки Connection та Statement,
         * які по завершенню читання/отримання інформації з БД потрібно буде ЗАКРИТИ, тому
         * для зменшення кількості коду, його оптимізації, рекомендується
         * скористатись блоком try з ресурсами (дозволить позбавитись громіздкого блоку finally)
         *
         * Розміщення ресурсів у дужках блоку try вказує, що вони будуть відкриті та
         * по завершенні роботи коду у тілі блоку закриватимуться у автоматичному режимі
         *
         * У даному методі використовуватиметься об'єкт-контейнер для зберігання результатів виборки - ResultSet
         * - Об'єкт ResultSet ініціалізується викликом методу executeQuery() від об'єкта statement
         * - метод executeQuery() повертає об'єкт-колекцію ResultSet
         * - метод executeQuery() приймає в параметри SQL-запит типу String на отримання даних з БД
         * - об'єкт ResultSet також є потоком та має бути закритий викликом методу .close() у блоці finally або потрібно використовувати try з ресурсами */
        try (Connection connection = DriverManager.getConnection(URL, USER_DB, PASSWORD); // створення з'єднання до БД
             Statement statement = connection.createStatement(); // створення об'єкта, через який виконуються запити до БД (повертає true/false)
             ResultSet resultSet = statement.executeQuery("SELECT * FROM users")) { // створення об'єкта, який при опрацюванні запиту поверне колекцію елементів (повертає ResultSet)

            // тіло блоку try-catch - тут знаходитиметься код, що потрібно безпечно виконати
            /** Опитування (опрос) об'єкта ResultSet
             * - використовується цикл while
             * - порядок роботи схожий на опитування об'єкта scanner при зчитуванні інф з файлу
             * - використовується метод next(), який повертає true/false та "пересуває внутрішній курсор" послідовно по повернених елементах */
            while (resultSet.next()) {
                /** При опитуванні об'єкта ResultSet до методу get...(), відповідно до отримуваного типу даних може передаватись
                 * - int columnIndex - номер колонки (починається з 1, нумерується зліва-направо) у таблиці БД з якої потрібно отримати дані
                 * - String columnLabel - назву колонки у таблиці бази даних - оскільки використання літералів у коді є поганим тоном,
                 * для передачі String параметрів до методу можна скористатись окремо створеними константами або створити окремий клас
                 * який буде описувати таблицю users - зберігати відповідні строкові константи для кожного поля */
                // отримання даних з полів таблиці
                long id = resultSet.getLong(1);
                String firstName = resultSet.getString(2);
                String lastName = resultSet.getString("lastName");

                // Створення нового об'єкта User на основі даних, отриманих з БД та додавання його до колекції, що повертатиметься методом
                users.add(new User(id, firstName, lastName));
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return users;
    }

    /**
     * Метод вмдалення елемента за id
     *
     * @param id - long - ідентифікатор елемента, який потрібно видалити
     */
    public static void deleteUserById(long id) {
        /** У даному методі також ВІДКРИВАТИМУТЬСЯ потоки Connection та Statement,
         * які по завершенню запису інформації до БД потрібно буде ЗАКРИТИ, тому
         * для зменшення кількості коду, його оптимізації, рекомендується
         * скористатись блоком try з ресурсами (дозволить позбавитись громіздкого блоку finally)
         *
         * Розміщення ресурсів у дужках блоку try вказує, що вони будуть відкриті та,
         * по завершенні роботи коду у тілі блоку, потребують закриття у автоматичному режимі */
        try (Connection connection = DriverManager.getConnection(URL, USER_DB, PASSWORD);
             Statement statement = connection.createStatement();) {

            // тіло блоку try-catch - тут знаходитиметься код, що потрібно безпечно виконати

            /** Запит на видалення елемента */
            statement.execute("DELETE FROM users WHERE id = " + id);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * Метод оновлення/зміни даних у БД
     *
     * @param user - User - змінений об'єкт з існуючим у БД id та зміненими (за потреби) firstName, lastName
     */
    public static void updateUser(User user) {
        /** У даному методі також ВІДКРИВАТИМУТЬСЯ потоки Connection та Statement,
         * які по завершенню запису інформації до БД потрібно буде ЗАКРИТИ, тому
         * для зменшення кількості коду, його оптимізації, рекомендується
         * скористатись блоком try з ресурсами (дозволить позбавитись громіздкого блоку finally)
         *
         * Розміщення ресурсів у дужках блоку try вказує, що вони будуть відкриті та,
         * по завершенні роботи коду у тілі блоку, потребують закриття у автоматичному режимі */
        try (Connection connection = DriverManager.getConnection(URL, USER_DB, PASSWORD);
             Statement statement = connection.createStatement();) {

            // тіло блоку try-catch - тут знаходитиметься код, що потрібно безпечно виконати

            /** Запит на оновлення даних у таблиці БД - SQL-запит
             * При створенні запиту слід зазначити, що строкові значення мають знаходитись у одинарних лапках '', а також
             * для передачі змінних класу до рядка запиту слід застосувати конкатенацію */
            statement.execute("UPDATE users SET firstName = '" + user.getFirstName() + "', lastName = '" + user.getLastName() + "' WHERE id = " + user.getId());

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

}
